
/*
Addition of natural numbers.
*/

sym nat;
use z;
use s;
use 1;
use 2;

sym add;

fn nat_add_ty : true -> (add' : nat' => nat' => nat') {
    axiom add_ty : true -> (add' : nat' => nat' => nat');
    x : true;
    let r = add_ty(x) : (add' : nat' => nat' => nat');
    return r;
}

fn nat_add_zero : (a : nat') -> add'(a, z') == a {
    axiom nat_add_zero : (a : nat') -> add'(a, z') == a;
    x : (a : nat');
    let r = nat_add_zero(x) : add'(a, z') == a;
    return r;
}

fn nat_add_succ : (a : nat') & (b : nat') -> add'(a, s'(b)) == s'(add'(a, b)) {
    axiom nat_add_succ : (a : nat') & (b : nat') -> add'(a, s'(b)) == s'(add'(a, b));
    x : (a : nat') & (b : nat');
    let r = nat_add_succ(x) : add'(a, s'(b)) == s'(add'(a, b));
    return r;
}

fn nat_add_eq_left : a == b -> add'(a, c) == add'(b, c) {
    axiom nat_add_eq_left : a == b -> add'(a, c) == add'(b, c);
    x : a == b;
    let r = nat_add_eq_left(x) : add'(a, c) == add'(b, c);
    return r;
}

fn nat_add_eq_right : a == b -> add'(c, a) == add'(c, b) {
    axiom nat_add_eq_right : a == b -> add'(c, a) == add'(c, b);
    x : a == b;
    let r = nat_add_eq_right(x) : add'(c, a) == add'(c, b);
    return r;
}

fn nat_one_plus_one_equals_two : true -> add'(1', 1') == 2' {
    x : true;

    use nat_one_eq;
    let x2 = nat_one_eq(x) : 1' == s'(z');
    use nat_one_ty;
    let x3 = nat_one_ty(x) : (1' : nat');
    use ty_eq_left;
    let x4 = ty_eq_left(x2) : (1' : nat') == (s'(z') : nat');
    use fst;
    let x5 = fst(x4) : (1' : nat') => (s'(z') : nat');
    let succ_ty = x5(x3) : (s'(z') : nat');
    use nat_zero_ty;
    let zero_ty = nat_zero_ty(x) : (z' : nat');
    use nat_add_succ;
    let x7 = nat_add_succ(succ_ty, zero_ty) : add'(s'(z'), s'(z')) == s'(add'(s'(z'), z'));

    use nat_add_zero;
    let y1 = nat_add_zero(succ_ty) : add'(s'(z'), z') == s'(z');
    use nat_succ_eq;
    let y2 = nat_succ_eq(y1) : s'(add'(s'(z'), z')) == s'(s'(z'));
    use eq_transitivity;
    let y3 = eq_transitivity(x7, y2) : add'(s'(z'), s'(z')) == s'(s'(z'));

    use nat_two_ty;
    let x8 = nat_two_ty(x) : (2' : nat');
    use nat_two_eq;
    let x9 = nat_two_eq(x) : 2' == s'(s'(z'));
    let x10 = ty_eq_left(x9) : (2' : nat') == (s'(s'(z')) : nat');
    let x11 = fst(x10) : (2' : nat') => (s'(s'(z')) : nat');
    let x12 = x11(x8) : (s'(s'(z')) : nat');
    use nat_add_zero;
    use eq_symmetry;
    let x15 = eq_symmetry(x9) : s'(s'(z')) == 2';
    let x16 = eq_transitivity(y3, x15) : add'(s'(z'), s'(z')) == 2';
    use nat_add_eq_left;
    let x17 = nat_add_eq_left(x2) : add'(1', s'(z')) == add'(s'(z'), s'(z'));
    let x18 = eq_transitivity(x17, x16) : add'(1', s'(z')) == 2';
    use nat_add_eq_right;
    let x19 = nat_add_eq_right(x2) : add'(1', 1') == add'(1', s'(z'));
    let r = eq_transitivity(x19, x18) : add'(1', 1') == 2';
    return r;
}

fn nat_add_check_all_ty : (a : nat') & (b : nat') -> (add'(a, b) : nat') {
    x : (a : nat');
    y : (b : nat');
    use ty_app2;
    use nat_add_ty;
    use triv;
    let x2 = triv(nat_add_ty) : (add' : nat' => nat' => nat');
    let r = ty_app2(x2, x, y) : (add'(a, b) : nat');
    return r;
}
