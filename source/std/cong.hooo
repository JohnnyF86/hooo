
sym cong;
sym tauto_cong;

fn cong_app : cong'(f) -> cong'(f(a)) {
    axiom cong_app : cong'(f) -> cong'(f(a));
    x : cong'(f);
    let r = cong_app(x) : cong'(f(a));
    return x;
}

fn cong_fun_eq : cong'(f) & cong'(g) & (f == g) -> f(a) == g(a) {
    axiom cong_fun_eq : cong'(f) & cong'(g) & (f == g) -> f(a) == g(a);
    x : cong'(f) & cong'(g) & (f == g);
    let r = cong_fun_eq(x) : f(a) == g(a);
    return r;
}

fn cong_to : cong'(f) -> sym(f, all(a == b -> f'(a) == f'(b)))(f) {
    axiom cong_to : cong'(f) -> sym(f, all(a == b -> f'(a) == f'(b)))(f);
    x : cong'(f);
    let r = cong_to(x) : sym(f, all(a == b -> f'(a) == f'(b)))(f);
    unsafe return r;
}

fn cong_from : sym(f, all(a == b -> f'(a) == f'(b)))(f) -> cong'(f) {
    axiom cong_from : sym(f, all(a == b -> f'(a) == f'(b)))(f) -> cong'(f);
    x : sym(f, all(a == b -> f'(a) == f'(b)))(f);
    let r = cong_from(x) : cong'(f);
    return r;
}

fn tauto_cong_to : tauto_cong'(f) -> sym(f, all((a == b)^true -> f'(a) == f'(b)))(f) {
    axiom tauto_cong_to : tauto_cong'(f) -> sym(f, all((a == b)^true -> f'(a) == f'(b)))(f);
    x : tauto_cong'(f);
    let r = tauto_cong_to(x) : sym(f, all((a == b)^true -> f'(a) == f'(b)))(f);
    unsafe return r;
}

fn tauto_cong_from : sym(f, all((a == b)^true -> f'(a) == f'(b)))(f) -> tauto_cong'(f) {
    axiom tauto_cong_from : sym(f, all((a == b)^true -> f'(a) == f'(b)))(f) -> tauto_cong'(f);
    x : sym(f, all((a == b)^true -> f'(a) == f'(b)))(f);
    let r = tauto_cong_from(x) : tauto_cong'(f);
    return r;
}

fn cong_eq_to_tauto_eq : sym(f, all(a == b -> f'(a) == f'(b)))(f) ->
    sym(f, all((a == b)^true -> f'(a) == f'(b)))(f)
{
    axiom cong_eq_to_tauto_eq : sym(f, all(a == b -> f'(a) == f'(b)))(f) ->
        sym(f, all((a == b)^true -> f'(a) == f'(b)))(f);
    x : sym(f, all(a == b -> f'(a) == f'(b)))(f);
    let r = cong_eq_to_tauto_eq(x) : sym(f, all((a == b)^true -> f'(a) == f'(b)))(f);
    unsafe return r;
}

fn cong_to_tauto_cong : cong'(f) -> tauto_cong'(f) {
    use cong_to;
    use cong_eq_to_tauto_eq;
    use tauto_cong_from;

    x : cong'(f);

    let x2 = cong_to(x) : sym(f, all((a == b) -> (f'(a) == f'(b))))(f);
    let x3 = cong_eq_to_tauto_eq(x2) : sym(f, all((a == b)^true -> (f'(a) == f'(b))))(f);    
    axiom r : tauto_cong'(f);
    return r;
}

fn cong_app_eq : cong'(f) & (a == b) -> f(a) == f(b) {
    use cong_to;

    x : cong'(f);
    y : a == b;

    let x2 = cong_to(x) : sym(f, (a == b) -> (f'(a) == f'(b)))(f);
    let x3 = x2() : (a == b) -> f(a) == f(b);
    let r = x3(y) : f(a) == f(b);
    return r;
}

fn cong_app_in_arg : cong'(f) & (f(a) == b) & (a == c) -> (f(c) == b) {
    use cong_app_eq;
    use eq_symmetry;
    use eq_transitivity;

    x : cong'(f);
    y : f(a) == b;
    z : a == c;

    let x2 = cong_app_eq(x, z) : f(a) == f(c);
    let x3 = eq_symmetry(x2) : f(c) == f(a);
    let r = eq_transitivity(x3, y) : f(c) == b;
    return r;
}

fn cong_sym : true -> cong'(sym(f, all(a == b -> f'(a) == f'(b)))) {
    axiom cong_sym : true -> cong'(sym(f, all(a == b -> f'(a) == f'(b))));
    x : true;
    let r = cong_sym(x) : cong'(sym(f, all(a == b -> f'(a) == f'(b))));
    return r;
}

fn cong_in_arg : cong'(f) & (f == g) -> cong'(g) {
    use cong_app_eq;
    use cong_from;
    use cong_sym;
    use cong_to;
    use fst;
    use triv;

    x : cong'(f);
    y : f == g;

    let x2 = cong_to(x) : sym(f, all(a == b -> f'(a) == f'(b)))(f);
    let x3 = triv(cong_sym) : cong'(sym(f, all(a == b -> f'(a) == f'(b))));
    let x5 = cong_app_eq(x3, y) :
        sym(f, all(a == b -> f'(a) == f'(b)))(f) ==
        sym(f, all(a == b -> f'(a) == f'(b)))(g);
    let x6 = fst(x5) :
        sym(f, all(a == b -> f'(a) == f'(b)))(f) =>
        sym(f, all(a == b -> f'(a) == f'(b)))(g);
    let x7 = x6(x2) : sym(f, all(a == b -> f'(a) == f'(b)))(g);
    let x8 = x7() : sym(g, all(a == b -> g'(a) == g'(b)))(g);
    let r = cong_from(x8) : cong'(g);
    return r;
}

fn cong_eq_left : cong'(f) & (a == b) -> f(a, c) == f(b, c) {
    use cong_app;
    use cong_app_eq;
    use cong_fun_eq;

    x : cong'(f);
    y : a == b;

    let x2 = cong_app(x) : cong'(f(a));
    let x3 = cong_app(x) : cong'(f(b));
    let x4 = cong_app_eq(x, y) : f(a) == f(b);
    let r = cong_fun_eq(x2, x3, x4) : f(a, c) == f(b, c);
    return r;
}

fn cong_eq_right : cong'(f) & (a == b) -> f(c, a) == f(c, b) {
    use cong_app;
    use cong_app_eq;

    x : cong'(f);
    y : a == b;

    let x2 = cong_app(x) : cong'(f(c));
    let r = cong_app_eq(x2, y) : f(c, a) == f(c, b);
    return r;
}

