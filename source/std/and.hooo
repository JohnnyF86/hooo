use cong;
use prop;

sym prop_and;

fn and_ty : true -> (prop_and' : prop' => prop' => prop') {
    axiom and_ty : true -> (prop_and' : prop' => prop' => prop');
    x : true;
    let r = and_ty(x) : (prop_and' : prop' => prop' => prop');
    return r;
}

fn and_def : true -> prop_and'(a, b) == (a & b) {
    axiom and_def : true -> prop_and'(a, b) == (a & b);
    x : true;
    let r = and_def(x) : prop_and'(a, b) == (a & b);
    return r;
}

fn and_cong : true -> cong'(prop_and') {
    axiom and_cong : true -> cong'(prop_and');
    x : true;
    let r = and_cong(x) : cong'(prop_and');
    return r;
}

fn and_map : a -> b => (a & b) {
    x : a;

    lam f : b => (a & b) {
        x2 : b;

        use refl;
        let x3 = refl(x, x2) : (a & b);
        return x3;
    }
    return f;
}

fn and_symmetry : a & b -> b & a {
    use fst;
    use snd;

    x : a & b;
    let y = fst(x) : a;
    let z = snd(x) : b;

    use refl;
    let r = refl(z, y) : (b & a);
    return r;
}

fn and_transitivity : (a & b) & (b & c)  ->  (a & c) {
    x : a & b;
    y : b & c;
    use fst;
    let x2 = fst(x) : a;
    use snd;
    let y2 = snd(y) : c;
    use refl;
    let r = refl(x2, y2) : a & c;
    return r;
}

fn fst : (a & b) -> a {
    x : a;
    y : b;
    return x;
}

fn snd : a & b -> b {
    x : a;
    y : b;
    return y;
}

