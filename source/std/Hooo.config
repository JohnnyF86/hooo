name: "std";
version: "0.2.0";
description: "Standard library for Hooo";
functions {
  absurd : false -> a;
  all_pow_absurd : all(b^a) -> c;
  and_map : a -> (b => (a & b));
  and_symmetry : (a & b) -> (b & a);
  and_transitivity : ((a & b) & (b & c)) -> (a & c);
  ava_ava : ((a, b(c)) & (b(c) : d)) -> (d(a) => b(c));
  ava_collide : ((b, q1(a1)) & ((b, q2(a2)) & ((q1(a1) : p) & (q2(a2) : p)))) -> (!(sd(q1, q2)));
  ava_lower_univ : (!~p & ((b, a) & (a : p))) -> (p(b) == a);
  ava_univ : (!~b & ((a, b) & (b : c))) -> (c(a) == b);
  bool_absurd : (fa' == tr') -> false;
  bool_and_cong : true -> cong'(and');
  bool_and_fa : true -> (and'(fa') == fa1');
  bool_and_fa_fa : true -> (and'(fa', fa') == fa');
  bool_and_fa_tr : true -> (and'(fa', tr') == fa');
  bool_and_in_left_arg : ((and'(a, b) == c) & (a == d)) -> (and'(d, b) == c);
  bool_and_in_right_arg : ((and'(a, b) == c) & (b == d)) -> (and'(a, d) == c);
  bool_and_same : (a : bool') -> (and'(a, a) == a);
  bool_and_symmetry : ((a : bool') & (b : bool')) -> (and'(a, b) == and'(b, a));
  bool_and_tr : true -> (and'(tr') == idb');
  bool_and_tr_fa : true -> (and'(tr', fa') == fa');
  bool_and_tr_tr : true -> (and'(tr', tr') == tr');
  bool_and_ty : true -> (and' : (bool' => (bool' => bool')));
  bool_def : (a : bool') -> ((a == fa') | (a == tr'));
  bool_eq_idb_self : (a : bool') -> (idb'(a) == a);
  bool_eq_not_not_self : (a : bool') -> (not'(not'(a)) == a);
  bool_fa1 : (a : bool') -> (fa1'(a) == fa');
  bool_fa1_cong : true -> cong'(fa1');
  bool_fa1_in_arg : ((fa1'(a) == b) & (a == c)) -> (fa1'(c) == b);
  bool_fa1_ty : true -> (fa1' : (bool' => bool'));
  bool_fa_ty : true -> (fa' : bool');
  bool_fun_eq : ((f : (bool' => c)) & ((g : (bool' => c)) & (f == g))) -> (f(a) == g(a));
  bool_idb_cong : true -> cong'(idb');
  bool_idb_fa : true -> (idb'(fa') == fa');
  bool_idb_in_arg : ((idb'(a) == b) & (a == c)) -> (idb'(c) == b);
  bool_idb_in_arg_sym : ((idb'(a) == b) & (c == a)) -> (idb'(c) == b);
  bool_idb_tr : true -> (idb'(tr') == tr');
  bool_idb_ty : true -> (idb' : (bool' => bool'));
  bool_not_cong : true -> cong'(not');
  bool_not_fa : true -> (not'(fa') == tr');
  bool_not_in_arg : ((not'(a) == b) & (a == c)) -> (not'(c) == b);
  bool_not_in_arg_sym : ((not'(a) == b) & (c == a)) -> (not'(c) == b);
  bool_not_tr : true -> (not'(tr') == fa');
  bool_not_ty : true -> (not' : (bool' => bool'));
  bool_or_cong : true -> cong'(or');
  bool_or_fa : true -> (or'(fa') == idb');
  bool_or_tr : true -> (or'(tr') == tr1');
  bool_or_ty : true -> (or' : (bool' => (bool' => bool')));
  bool_tr1 : (a : bool') -> (tr1'(a) == tr');
  bool_tr1_cong : true -> cong'(tr1');
  bool_tr1_in_arg : ((tr1'(a) == b) & (a == c)) -> (tr1'(c) == b);
  bool_tr1_ty : true -> (tr1' : (bool' => bool'));
  bool_tr_ty : true -> (tr' : bool');
  bool_ty : true -> (bool' : type'(z'));
  comp : (c^b & b^a) -> (c^a);
  cong_app : cong'(f) -> cong'(f(a));
  cong_app_eq : (cong'(f) & (a == b)) -> (f(a) == f(b));
  cong_app_in_arg : (cong'(f) & ((f(a) == b) & (a == c))) -> (f(c) == b);
  cong_from : (sym(f, (a == b) -> (f'(a) == f'(b))))(f) -> cong'(f);
  cong_fun_eq : (cong'(f) & (cong'(g) & (f == g))) -> (f(a) == g(a));
  cong_to : cong'(f) -> (sym(f, (a == b) -> (f'(a) == f'(b))))(f);
  cong_to_tauto_cong : cong'(f) -> tauto_cong'(f);
  curry : ((a & b) => c) -> (a => (b => c));
  eq_modus_tollens : (a == b) -> (!a == !b);
  eq_symmetry : (a == b) -> (b == a);
  eq_transitivity : ((a == b) & (b == c)) -> (a == c);
  eq_transitivity_sym : ((a == b) & (c == b)) -> (a == c);
  exists_from : (!((!b)^a)) -> ex'(a, b);
  exists_from_imply : (!(a => !b)) -> ex'(a, b);
  exists_to : ex'(a, b) -> (!((!b)^a));
  fst : (a & b) -> a;
  hooo_and : ((a & b)^c) -> (a^c & b^c);
  hooo_imply : ((a => b)^c) -> (a^c => b^c);
  hooo_or : ((a | b)^c) -> (a^c | b^c);
  hooo_rev_and : (a^c & b^c) -> ((a & b)^c);
  hooo_rev_or : (a^c | b^c) -> ((a | b)^c);
  imply_eq_left : (a == b) -> ((a => c) == (b => c));
  imply_in_left_arg : ((a => b) & (a == c)) -> (c => b);
  imply_in_right_arg : ((a => b) & (b == c)) -> (a => c);
  imply_transitivity : ((a => b) & (b => c)) -> (a => c);
  left : a -> (a | b);
  lob_absurd : all((p^true => p)^true => p^true) -> false;
  lob_triv : true -> (p^true => p);
  modal_k_from : (□(a => b) => (□a => □b)) -> K'(a, b);
  modal_k_to : K'(a, b) -> (□(a => b) => (□a => □b));
  modal_lob_from : (□(□a => a) => □a) -> Lob'(a);
  modal_lob_to : Lob'(a) -> (□(□a => a) => □a);
  modal_n2_from : (□a == (a^true)) -> N2'(a);
  modal_n2_to : N2'(a) -> (□a == (a^true));
  modal_n2_to_k : all(N2'(a)) -> K'(a, b);
  modal_n2_to_n : N2'(a) -> N'(a);
  modal_n2_to_nlob : all(N2'(a)) -> (!all(Lob'(a)));
  modal_n2_to_t : all(N2'(a)) -> T'(a);
  modal_n_from : (a^true => □a) -> N'(a);
  modal_n_to : N'(a) -> (a^true => □a);
  modal_n_to_nlob : (all(N'(a)) & false^(□false)) -> (!all(Lob'(a)));
  modal_nec_eq : (a == b) -> (□a == □b);
  modal_nec_in_arg : (□a & (a == b)) -> (□b);
  modal_nec_to_pos_from : (□a == !◇!a) -> NecToPos'(a);
  modal_nec_to_pos_to : NecToPos'(a) -> (□a == !◇!a);
  modal_pos_eq : (a == b) -> (◇a == ◇b);
  modal_pos_in_arg : (◇a & (a == b)) -> (◇b);
  modal_pos_to_nec_from : (◇a == !□!a) -> PosToNec'(a);
  modal_pos_to_nec_to : PosToNec'(a) -> (◇a == !□!a);
  modal_t_from : (□a => a) -> T'(a);
  modal_t_to : T'(a) -> (□a => a);
  modal_tauto_excm_to_imply_nec_to_pos_pos_to_nec : all(excm(a)^true) -> (all(NecToPos'(a)) => PosToNec'(a));
  modal_tauto_excm_to_imply_pos_to_nec_nec_to_pos : all(excm(a)^true) -> (all(PosToNec'(a)) => NecToPos'(a));
  modal_tauto_n2_to_para_nec_false : (all(N2'(a))^true) -> (false^(□false));
  modal_tauto_t_to_para_nec_false : (all(T'(a))^true) -> (false^(□false));
  modus_ponens : (a & (a => b)) -> b;
  modus_tollens : (a => b) -> (!b => !a);
  nat_add_check_all_ty : ((a : nat') & (b : nat')) -> (add'(a, b) : nat');
  nat_add_eq_left : (a == b) -> (add'(a, c) == add'(b, c));
  nat_add_eq_right : (a == b) -> (add'(c, a) == add'(c, b));
  nat_add_succ : ((a : nat') & (b : nat')) -> (add'(a, s'(b)) == s'(add'(a, b)));
  nat_add_ty : true -> (add' : (nat' => (nat' => nat')));
  nat_add_zero : (a : nat') -> (add'(a, z') == a);
  nat_def : (a : nat') -> ((a == z') | ((prev'(a) : nat') & (a == s'(prev'(a)))));
  nat_eq_succ_lower : (s'(a) == s'(b)) -> (a == b);
  nat_ind : (ex'(z' : nat', a) & ex'(s'(n) : nat', a)) -> a;
  nat_neq_zero_one : true -> (!(z' == s'(z')));
  nat_one_eq : true -> (1' == s'(z'));
  nat_one_from : s'(z') -> 1';
  nat_one_plus_one_equals_two : true -> (add'(1', 1') == 2');
  nat_one_to : 1' -> s'(z');
  nat_one_ty : true -> (1' : nat');
  nat_para_eq_prev : (a == prev'(a)) -> false;
  nat_para_eq_succ : ((a : nat') & (a == s'(a))) -> false;
  nat_para_eq_zero_pos : (z' == s'(a)) -> false;
  nat_succ_eq : (a == b) -> (s'(a) == s'(b));
  nat_succ_ty : (a : nat') -> (s'(a) : nat');
  nat_two_eq : true -> (2' == s'(s'(z')));
  nat_two_from : s'(s'(z')) -> 2';
  nat_two_to : 2' -> s'(s'(z'));
  nat_two_ty : true -> (2' : nat');
  nat_ty : true -> (nat' : type'(z'));
  nat_zero_ty : true -> (z' : nat');
  neq_to_sesh : (!(a == b)) -> (!(a ~~ b));
  nleft : (!(a | b)) -> (!a);
  not_double : a -> (!!a);
  not_excm_to_eq_nn : excm(a) -> (a == !!a);
  not_rev_double_excm : (!!a & excm(a)) -> a;
  not_rev_triple : (!!!a) -> (!a);
  not_to_not_tauto : (!a) -> (!(a^true));
  nqu_to_sesh : (!~a) -> (!(a ~~ a));
  nright : (!(a | b)) -> (!b);
  or_symmetry : (a | b) -> (b | a);
  para_lob : ((!(false^true))^true => false^true) -> false;
  para_to_tauto_not : (false^a) -> ((!a)^true);
  para_to_uniform : (false^a) -> uniform'(a);
  pow_and_lift : (a^b & c^d) -> ((a^b & c^d)^e);
  pow_eq_to_tauto_eq : (a =^= b) -> ((a == b)^true);
  pow_in_left_arg : (a^b & (a == c)^true) -> (c^b);
  pow_in_right_arg : (a^b & (b == c)^true) -> (a^c);
  pow_lift : (a^b) -> ((a^b)^c);
  pow_modus_tollens : (b^a) -> ((!a)^(!b));
  pow_or_lift : (a^b | c^d) -> ((a^b | c^d)^e);
  pow_to_imply : (b^a) -> (a => b);
  pow_to_imply_lift : (b^a) -> ((a => b)^c);
  pow_to_pow_tauto : (a^b) -> (a^(b^true));
  pow_to_tauto_imply : (a^b) -> ((b => a)^true);
  pow_transitivity : (b^a & c^b) -> (c^a);
  ps_core : ((a ~~ b) & ((a : c) & (b : d))) -> (c ~~ d);
  ps_nqu_mem : (!~b & (a : b)) -> (!~a);
  ps_sesh_mem : (!(b ~~ b) & (a : b)) -> (!(a ~~ a));
  q_from : ((a == b) & (~a & ~b)) -> (a ~~ b);
  q_left : (a ~~ b) -> (a ~~ a);
  q_lift : ((sd(a, b)) & (a == b)) -> (a ~~ b);
  q_right : (a ~~ b) -> (b ~~ b);
  q_symmetry : (a ~~ b) -> (b ~~ a);
  q_to : (a ~~ b) -> ((a == b) & (~a & ~b));
  q_to_eq : (a ~~ b) -> (a == b);
  q_to_qu : (a ~~ a) -> (~a);
  q_transitivity : ((a ~~ b) & (b ~~ c)) -> (a ~~ c);
  qu_in_arg : (~a & (a == b)^true) -> (~b);
  qu_to_q : (~a) -> (a ~~ a);
  refl : a -> a;
  rev_modus_tollens_nn : (!!a => !!b) -> (!b => !a);
  right : b -> (a | b);
  sd_in_left_arg : ((sd(a, b)) & (a == c)^true) -> (sd(c, b));
  sd_in_right_arg : ((sd(a, b)) & (b == c)^true) -> (sd(a, c));
  sd_symmetry : (sd(a, b)) -> (sd(b, a));
  sesh_left : (!(a ~~ a)) -> (!(a ~~ b));
  sesh_right : (!(b ~~ b)) -> (!(a ~~ b));
  snd : (a & b) -> b;
  sym_from : (sym(a, a'))(a) -> a;
  sym_pow_to_pow_tauto : (sym(f, b -> a))(f) -> (sym(f, (b^true) -> a))(f);
  sym_unwrap : (sym(a, b))(a) -> b;
  tauto_cong_from : (sym(f, ((a == b)^true) -> (f'(a) == f'(b))))(f) -> tauto_cong'(f);
  tauto_cong_to : tauto_cong'(f) -> (sym(f, ((a == b)^true) -> (f'(a) == f'(b))))(f);
  tauto_eq_refl : true -> (a == a);
  tauto_eq_to_pow_eq : ((a == b)^true) -> (a =^= b);
  tauto_excm_to_uniform : (excm(a)^true) -> uniform'(a);
  tauto_hooo_and : ((a & b)^c) -> ((a^c & b^c)^true);
  tauto_hooo_imply : ((a => b)^c) -> ((a^c => b^c)^true);
  tauto_hooo_or : ((a | b)^c) -> ((a^c | b^c)^true);
  tauto_hooo_rev_and : ((a^c & b^c)^true) -> ((a & b)^c);
  tauto_imply_refl : true -> (a => a);
  tauto_imply_to_pow : ((a => b)^true) -> (b^a);
  tauto_nnexcm : true -> (!!excm(a));
  tauto_not_to_para : ((!a)^true) -> (false^a);
  tauto_to_uniform : (a^true) -> uniform'(a);
  tauto_uniform_eq : true -> (uniform'(a) == (a^true | false^a));
  theory_from : (!uniform'(a)) -> theory'(a);
  theory_to : theory'(a) -> (!uniform'(a));
  theory_to_nor_tauto_para : theory'(a) -> (!(a^true | false^a));
  theory_to_npara : theory'(a) -> (!(false^a));
  theory_to_ntauto : theory'(a) -> (!(a^true));
  triv : (a^true) -> a;
  ty_app : ((f : (a => b)) & (a2 : a)) -> (f(a2) : b);
  ty_app2 : ((f : (a => (b => c))) & ((a2 : a) & (b2 : b))) -> (f(a2, b2) : c);
  ty_eq_left : (a == b) -> ((a : c) == (b : c));
  ty_eq_right : (a == b) -> ((c : a) == (c : b));
  ty_fun : ((a : at) & (b : bt)) -> ((a => b) : (at => bt));
  ty_fun_ty : true -> (type'(a) => (type'(b) : type'(z')));
  ty_sd_to_neq : ((sd(a, b)) & ((a : type'(z')) & (b : type'(z')))) -> (!(a == b));
  ty_uniq : (!(a == b) & ((c : a) == (c : b))) -> false;
  uncurry : (a => (b => c)) -> ((a & b) => c);
  uniform_from : (a^true | false^a) -> uniform'(a);
  uniform_to : uniform'(a) -> (a^true | false^a);
  uniform_to_tauto_excm : uniform'(a) -> (excm(a)^true);
  unify : ((a | b) & ((a => c) & (b => c))) -> c;
}
dependencies {
}
