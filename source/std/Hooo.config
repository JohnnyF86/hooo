name: "std";
version: "0.2.0";
description: "Standard library for Hooo";
functions {
  absurd : false -> a;
  all_pow_absurd : all(b^a) -> c;
  and_map : a -> (b => (a & b));
  and_symmetry : (a & b) -> (b & a);
  comp : (c^b & b^a) -> (c^a);
  curry : ((a & b) => c) -> (a => (b => c));
  eq_modus_tollens : (a == b) -> (!a == !b);
  eq_symmetry : (a == b) -> (b == a);
  eq_transitivity : ((a == b) & (b == c)) -> (a == c);
  fst : (a & b) -> a;
  hooo_and : ((a & b)^c) -> (a^c & b^c);
  hooo_imply : ((a => b)^c) -> (a^c => b^c);
  hooo_or : ((a | b)^c) -> (a^c | b^c);
  hooo_rev_and : (a^c & b^c) -> ((a & b)^c);
  hooo_rev_or : (a^c | b^c) -> ((a | b)^c);
  imply_eq_left : (a == b) -> ((a => c) == (b => c));
  imply_in_left_arg : ((a => b) & (a == c)) -> (c => b);
  imply_in_right_arg : ((a => b) & (b == c)) -> (a => c);
  imply_transitivity : ((a => b) & (b => c)) -> (a => c);
  left : a -> (a | b);
  lob_absurd : all((p^true => p)^true => p^true) -> false;
  lob_triv : true -> (p^true => p);
  modal_k_from : (nec(a => b) => (nec(a) => nec(b))) -> K(a, b);
  modal_k_to : K(a, b) -> (nec(a => b) => (nec(a) => nec(b)));
  modal_lob_from : (nec(nec(a) => a) => nec(a)) -> Lob(a);
  modal_lob_to : Lob(a) -> (nec(nec(a) => a) => nec(a));
  modal_n2_from : (nec(a) == (a^true)) -> N2(a);
  modal_n2_to : N2(a) -> (nec(a) == (a^true));
  modal_n2_to_k : all(N2(a)) -> K(a, b);
  modal_n2_to_n : N2(a) -> N(a);
  modal_n2_to_nlob : all(N2(a)) -> (!all(Lob(a)));
  modal_n2_to_t : all(N2(a)) -> T(a);
  modal_n_from : (a^true => nec(a)) -> N(a);
  modal_n_to : N(a) -> (a^true => nec(a));
  modal_n_to_nlob : (all(N(a)) & false^nec(false)) -> (!all(Lob(a)));
  modal_nec_eq : (a == b) -> (nec(a) == nec(b));
  modal_nec_in_arg : (nec(a) & (a == b)) -> nec(b);
  modal_nec_to_pos_from : (nec(a) == !pos(!a)) -> NecToPos(a);
  modal_nec_to_pos_to : NecToPos(a) -> (nec(a) == !pos(!a));
  modal_pos_eq : (a == b) -> (pos(a) == pos(b));
  modal_pos_in_arg : (pos(a) & (a == b)) -> pos(b);
  modal_pos_to_nec_from : (pos(a) == !nec(!a)) -> PosToNec(a);
  modal_pos_to_nec_to : PosToNec(a) -> (pos(a) == !nec(!a));
  modal_t_from : (nec(a) => a) -> T(a);
  modal_t_to : T(a) -> (nec(a) => a);
  modal_tauto_excm_to_imply_nec_to_pos_pos_to_nec : all(excm(a)^true) -> (all(NecToPos(a)) => PosToNec(a));
  modal_tauto_excm_to_imply_pos_to_nec_nec_to_pos : all(excm(a)^true) -> (all(PosToNec(a)) => NecToPos(a));
  modal_tauto_n2_to_para_nec_false : (all(N2(a))^true) -> (false^nec(false));
  modus_ponens : (a & (a => b)) -> b;
  modus_tollens : (a => b) -> (!b => !a);
  nleft : (!(a | b)) -> (!a);
  not_double : a -> (!!a);
  not_excm_to_eq_nn : excm(a) -> (a == !!a);
  not_rev_double_excm : (!!a & excm(a)) -> a;
  not_rev_triple : (!!!a) -> (!a);
  nright : (!(a | b)) -> (!b);
  or_symmetry : (a | b) -> (b | a);
  para_lob : ((!(false^true))^true => false^true) -> false;
  para_to_tauto_not : (false^a) -> ((!a)^true);
  para_to_uniform : (false^a) -> uniform(a);
  pow_eq_to_tauto_eq : (b =^= a) -> ((a == b)^true);
  pow_in_left_arg : (a^b & (a == c)^true) -> (c^b);
  pow_in_right_arg : (a^b & (b == c)^true) -> (a^c);
  pow_lift : (a^b) -> ((a^b)^c);
  pow_to_imply : (b^a) -> (a => b);
  pow_to_imply_lift : (b^a) -> ((a => b)^c);
  pow_to_tauto_imply : (a^b) -> ((b => a)^true);
  pow_transitivity : (b^a & c^b) -> (c^a);
  refl : a -> a;
  rev_modus_tollens_nn : (!!a => !!b) -> (!b => !a);
  right : b -> (a | b);
  snd : (a & b) -> b;
  tauto_eq_refl : true -> (a == a);
  tauto_eq_to_pow_eq : ((a == b)^true) -> (a =^= b);
  tauto_excm_to_uniform : (excm(a)^true) -> uniform(a);
  tauto_hooo_and : ((a & b)^c) -> ((a^c & b^c)^true);
  tauto_hooo_imply : ((a => b)^c) -> ((a^c => b^c)^true);
  tauto_hooo_or : ((a | b)^c) -> ((a^c | b^c)^true);
  tauto_hooo_rev_and : ((a^c & b^c)^true) -> ((a & b)^c);
  tauto_imply_refl : true -> (a => a);
  tauto_nnexcm : true -> (!!excm(a));
  tauto_not_to_para : ((!a)^true) -> (false^a);
  tauto_to_uniform : (a^true) -> uniform(a);
  tauto_uniform_eq : true -> (uniform(a) == (a^true | false^a));
  theory_from : (!uniform(a)) -> theory(a);
  theory_to : theory(a) -> (!uniform(a));
  theory_to_nor_tauto_para : theory(a) -> (!(a^true | false^a));
  theory_to_npara : theory(a) -> (!(false^a));
  theory_to_ntauto : theory(a) -> (!(a^true));
  triv : (a^true) -> a;
  uncurry : (a => (b => c)) -> ((a & b) => c);
  uniform_from : (a^true | false^a) -> uniform(a);
  uniform_to : uniform(a) -> (a^true | false^a);
  uniform_to_tauto_excm : uniform(a) -> (excm(a)^true);
  unify : ((a | b) & ((a => c) & (b => c))) -> c;
}
dependencies {
}
