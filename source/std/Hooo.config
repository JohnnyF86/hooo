name: "std";
version: "0.2.0";
description: "Standard library for Hooo";
functions {
  absurd : false -> a;
  all_pow_absurd : all(b^a) -> c;
  and_map : a -> (b => (a & b));
  and_symmetry : (a & b) -> (b & a);
  comp : (c^b & b^a) -> (c^a);
  curry : ((a & b) => c) -> (a => (b => c));
  eq_modus_tollens : (a == b) -> (!a == !b);
  eq_symmetry : (a == b) -> (b == a);
  eq_transitivity : ((a == b) & (b == c)) -> (a == c);
  exists_from : (!((!b)^a)) -> ex'(a, b);
  exists_from_imply : (!(a => !b)) -> ex'(a, b);
  exists_to : ex'(a, b) -> (!((!b)^a));
  fst : (a & b) -> a;
  hooo_and : ((a & b)^c) -> (a^c & b^c);
  hooo_imply : ((a => b)^c) -> (a^c => b^c);
  hooo_or : ((a | b)^c) -> (a^c | b^c);
  hooo_rev_and : (a^c & b^c) -> ((a & b)^c);
  hooo_rev_or : (a^c | b^c) -> ((a | b)^c);
  imply_eq_left : (a == b) -> ((a => c) == (b => c));
  imply_in_left_arg : ((a => b) & (a == c)) -> (c => b);
  imply_in_right_arg : ((a => b) & (b == c)) -> (a => c);
  imply_transitivity : ((a => b) & (b => c)) -> (a => c);
  left : a -> (a | b);
  lob_absurd : all((p^true => p)^true => p^true) -> false;
  lob_triv : true -> (p^true => p);
  modal_k_from : (nec'(a => b) => (nec'(a) => nec'(b))) -> K'(a, b);
  modal_k_to : K'(a, b) -> (nec'(a => b) => (nec'(a) => nec'(b)));
  modal_lob_from : (nec'(nec'(a) => a) => nec'(a)) -> Lob'(a);
  modal_lob_to : Lob'(a) -> (nec'(nec'(a) => a) => nec'(a));
  modal_n2_from : (nec'(a) == (a^true)) -> N2'(a);
  modal_n2_to : N2'(a) -> (nec'(a) == (a^true));
  modal_n2_to_k : all(N2'(a)) -> K'(a, b);
  modal_n2_to_n : N2'(a) -> N'(a);
  modal_n2_to_nlob : all(N2'(a)) -> (!all(Lob'(a)));
  modal_n2_to_t : all(N2'(a)) -> T'(a);
  modal_n_from : (a^true => nec'(a)) -> N'(a);
  modal_n_to : N'(a) -> (a^true => nec'(a));
  modal_n_to_nlob : (all(N'(a)) & false^nec'(false)) -> (!all(Lob'(a)));
  modal_nec_eq : (a == b) -> (nec'(a) == nec'(b));
  modal_nec_in_arg : (nec'(a) & (a == b)) -> nec'(b);
  modal_nec_to_pos_from : (nec'(a) == !pos'(!a)) -> NecToPos'(a);
  modal_nec_to_pos_to : NecToPos'(a) -> (nec'(a) == !pos'(!a));
  modal_pos_eq : (a == b) -> (pos'(a) == pos'(b));
  modal_pos_in_arg : (pos'(a) & (a == b)) -> pos'(b);
  modal_pos_to_nec_from : (pos'(a) == !nec'(!a)) -> PosToNec'(a);
  modal_pos_to_nec_to : PosToNec'(a) -> (pos'(a) == !nec'(!a));
  modal_t_from : (nec'(a) => a) -> T'(a);
  modal_t_to : T'(a) -> (nec'(a) => a);
  modal_tauto_excm_to_imply_nec_to_pos_pos_to_nec : all(excm(a)^true) -> (all(NecToPos'(a)) => PosToNec'(a));
  modal_tauto_excm_to_imply_pos_to_nec_nec_to_pos : all(excm(a)^true) -> (all(PosToNec'(a)) => NecToPos'(a));
  modal_tauto_n2_to_para_nec_false : (all(N2'(a))^true) -> (false^nec'(false));
  modal_tauto_t_to_para_nec_false : (all(T'(a))^true) -> (false^nec'(false));
  modus_ponens : (a & (a => b)) -> b;
  modus_tollens : (a => b) -> (!b => !a);
  nat_add_check_all_ty : (ty'(a, nat') & ty'(b, nat')) -> ty'(add'(a, b), nat');
  nat_add_eq_left : (a == b) -> (add'(a, c) == add'(b, c));
  nat_add_eq_right : (a == b) -> (add'(c, a) == add'(c, b));
  nat_add_succ : (ty'(a, nat') & ty'(b, nat')) -> (add'(a, s'(b)) == s'(add'(a, b)));
  nat_add_ty : true -> ty'(add', nat' => (nat' => nat'));
  nat_add_zero : ty'(a, nat') -> (add'(a, z') == a);
  nat_def : ty'(a, nat') -> ((a == z') | (ty'(prev'(a), nat') & (a == s'(prev'(a)))));
  nat_eq_succ_lower : (s'(a) == s'(b)) -> (a == b);
  nat_ind : (ex'(ty'(z', nat'), a) & ex'(ty'(s'(n), nat'), a)) -> a;
  nat_neq_zero_one : true -> (!(z' == s'(z')));
  nat_one_eq : true -> (1' == s'(z'));
  nat_one_from : s'(z') -> 1';
  nat_one_plus_one_equals_two : true -> (add'(1', 1') == 2');
  nat_one_to : 1' -> s'(z');
  nat_one_ty : true -> ty'(1', nat');
  nat_para_eq_prev : (a == prev'(a)) -> false;
  nat_para_eq_succ : (ty'(a, nat') & (a == s'(a))) -> false;
  nat_para_eq_zero_pos : (z' == s'(a)) -> false;
  nat_succ_eq : (a == b) -> (s'(a) == s'(b));
  nat_succ_ty : ty'(a, nat') -> ty'(s'(a), nat');
  nat_two_eq : true -> (2' == s'(s'(z')));
  nat_two_from : s'(s'(z')) -> 2';
  nat_two_to : 2' -> s'(s'(z'));
  nat_two_ty : true -> ty'(2', nat');
  nat_zero_ty : true -> ty'(z', nat');
  nleft : (!(a | b)) -> (!a);
  not_double : a -> (!!a);
  not_excm_to_eq_nn : excm(a) -> (a == !!a);
  not_rev_double_excm : (!!a & excm(a)) -> a;
  not_rev_triple : (!!!a) -> (!a);
  not_to_not_tauto : (!a) -> (!(a^true));
  nright : (!(a | b)) -> (!b);
  or_symmetry : (a | b) -> (b | a);
  para_lob : ((!(false^true))^true => false^true) -> false;
  para_to_tauto_not : (false^a) -> ((!a)^true);
  para_to_uniform : (false^a) -> uniform'(a);
  pow_eq_to_tauto_eq : (a =^= b) -> ((a == b)^true);
  pow_in_left_arg : (a^b & (a == c)^true) -> (c^b);
  pow_in_right_arg : (a^b & (b == c)^true) -> (a^c);
  pow_lift : (a^b) -> ((a^b)^c);
  pow_modus_tollens : (b^a) -> ((!a)^(!b));
  pow_to_imply : (b^a) -> (a => b);
  pow_to_imply_lift : (b^a) -> ((a => b)^c);
  pow_to_tauto_imply : (a^b) -> ((b => a)^true);
  pow_transitivity : (b^a & c^b) -> (c^a);
  refl : a -> a;
  rev_modus_tollens_nn : (!!a => !!b) -> (!b => !a);
  right : b -> (a | b);
  snd : (a & b) -> b;
  tauto_eq_refl : true -> (a == a);
  tauto_eq_to_pow_eq : ((a == b)^true) -> (a =^= b);
  tauto_excm_to_uniform : (excm(a)^true) -> uniform'(a);
  tauto_hooo_and : ((a & b)^c) -> ((a^c & b^c)^true);
  tauto_hooo_imply : ((a => b)^c) -> ((a^c => b^c)^true);
  tauto_hooo_or : ((a | b)^c) -> ((a^c | b^c)^true);
  tauto_hooo_rev_and : ((a^c & b^c)^true) -> ((a & b)^c);
  tauto_imply_refl : true -> (a => a);
  tauto_imply_to_pow : ((a => b)^true) -> (b^a);
  tauto_nnexcm : true -> (!!excm(a));
  tauto_not_to_para : ((!a)^true) -> (false^a);
  tauto_to_uniform : (a^true) -> uniform'(a);
  tauto_uniform_eq : true -> (uniform'(a) == (a^true | false^a));
  theory_from : (!uniform'(a)) -> theory'(a);
  theory_to : theory'(a) -> (!uniform'(a));
  theory_to_nor_tauto_para : theory'(a) -> (!(a^true | false^a));
  theory_to_npara : theory'(a) -> (!(false^a));
  theory_to_ntauto : theory'(a) -> (!(a^true));
  triv : (a^true) -> a;
  ty_app : (ty(f, a => b) & ty(a2, a)) -> ty(f(a2), b);
  ty_app2 : (ty(f, a => (b => c)) & (ty(a2, a) & ty(b2, b))) -> ty(f(a2, b2), c);
  ty_eq_left : (a == b) -> (ty'(a, c) == ty'(b, c));
  ty_eq_right : (a == b) -> (ty'(c, a) == ty'(c, b));
  uncurry : (a => (b => c)) -> ((a & b) => c);
  uniform_from : (a^true | false^a) -> uniform'(a);
  uniform_to : uniform'(a) -> (a^true | false^a);
  uniform_to_tauto_excm : uniform'(a) -> (excm(a)^true);
  unify : ((a | b) & ((a => c) & (b => c))) -> c;
}
dependencies {
}
