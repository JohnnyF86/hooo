name: "std";
version: "0.2.0";
description: "Standard library for Hooo";
functions {
  absurd : false -> a;
  all_pow_absurd : all(b^a) -> c;
  and_map : a -> (b => (a & b));
  and_symmetry : (a & b) -> (b & a);
  comp : (c^b & b^a) -> (c^a);
  curry : ((a & b) => c) -> (a => (b => c));
  eq_symmetry : (a == b) -> (b == a);
  eq_transitivity : ((a == b) & (b == c)) -> (a == c);
  fst : (a & b) -> a;
  hooo_and : ((a & b)^c) -> (a^c & b^c);
  hooo_imply : ((a => b)^c) -> (a^c => b^c);
  hooo_or : ((a | b)^c) -> (a^c | b^c);
  hooo_rev_and : (a^c & b^c) -> ((a & b)^c);
  hooo_rev_or : (a^c | b^c) -> ((a | b)^c);
  imply_in_left_arg : ((a => b) & (a == c)) -> (c => b);
  imply_in_right_arg : ((a => b) & (b == c)) -> (a => c);
  imply_transitivity : ((a => b) & (b => c)) -> (a => c);
  left : a -> (a | b);
  lob_absurd : all((p^true => p)^true => p^true) -> false;
  lob_triv : true -> (p^true => p);
  modal_k_from : (nec(a => b) => (nec(a) => nec(b))) -> K(a, b);
  modal_k_to : K(a, b) -> (nec(a => b) => (nec(a) => nec(b)));
  modal_n_from : N(a) -> (a^true => nec(a));
  modal_n_to : N(a) -> (nec(a) => a^true);
  modal_n_to_k : all(N(a)) -> K(a, b);
  modal_n_to_t : all(N(a)) -> T(a);
  modal_t_from : (nec(a) => a) -> T(a);
  modal_t_to : T(a) -> (nec(a) => a);
  modus_ponens : (a & (a => b)) -> b;
  modus_tollens : (a => b) -> (!b => !a);
  nleft : (!(a | b)) -> (!a);
  not_double : a -> (!!a);
  not_rev_double_excm : (!!a & excm(a)) -> a;
  not_rev_triple : (!!!a) -> (!a);
  nright : (!(a | b)) -> (!b);
  or_symmetry : (a | b) -> (b | a);
  para_lob : ((!(false^true))^true => false^true) -> false;
  para_to_uniform : (false^a) -> uniform(a);
  pow_eq_to_tauto_eq : (b =^= a) -> ((a == b)^true);
  pow_in_left_arg : (a^b & (a == c)^true) -> (c^b);
  pow_in_right_arg : (a^b & (b == c)^true) -> (a^c);
  pow_lift : (a^b) -> ((a^b)^c);
  pow_to_imply : (b^a) -> (a => b);
  pow_to_imply_lift : (b^a) -> ((a => b)^c);
  pow_to_tauto_imply : (a^b) -> ((b => a)^true);
  pow_transitivity : (b^a & c^b) -> (c^a);
  refl : a -> a;
  right : b -> (a | b);
  snd : (a & b) -> b;
  tauto_eq_refl : true -> (a == a);
  tauto_eq_to_pow_eq : ((a == b)^true) -> (a =^= b);
  tauto_excm_to_uniform : (excm(a)^true) -> uniform(a);
  tauto_hooo_and : ((a & b)^c) -> ((a^c & b^c)^true);
  tauto_hooo_imply : ((a => b)^c) -> ((a^c => b^c)^true);
  tauto_hooo_or : ((a | b)^c) -> ((a^c | b^c)^true);
  tauto_hooo_rev_and : ((a^c & b^c)^true) -> ((a & b)^c);
  tauto_imply_refl : true -> (a => a);
  tauto_nnexcm : true -> (!!excm(a));
  tauto_not_to_para : ((!a)^true) -> (false^a);
  tauto_to_uniform : (a^true) -> uniform(a);
  tauto_uniform_eq : true -> (uniform(a) == (a^true | false^a));
  theory_from : (!uniform(a)) -> theory(a);
  theory_to : theory(a) -> (!uniform(a));
  theory_to_nor_tauto_para : theory(a) -> (!(a^true | false^a));
  theory_to_npara : theory(a) -> (!(false^a));
  theory_to_ntauto : theory(a) -> (!(a^true));
  triv : (a^true) -> a;
  uncurry : (a => (b => c)) -> ((a & b) => c);
  uniform_from : (a^true | false^a) -> uniform(a);
  uniform_to : uniform(a) -> (a^true | false^a);
  uniform_to_tauto_excm : uniform(a) -> (excm(a)^true);
  unify : ((a | b) & ((a => c) & (b => c))) -> c;
}
dependencies {
}
