
use cong;
use ex;
use type;

sym nat;
sym z;
sym s;
sym prev;
sym 1;
sym 2;

fn nat_ty : true -> (nat' : type'(z')) {
    axiom nat_ty : true -> (nat' : type'(z'));
    x : true;
    let r = nat_ty(x) : (nat' : type'(z'));
    return r;
}

fn nat_zero_ty : true -> (z' : nat') {
    axiom nat_zero_ty : true -> (z' : nat');
    x : true;
    let r = nat_zero_ty(x) : (z' : nat');
    return r;
}

fn nat_succ_ty : (a : nat') -> (s'(a) : nat') {
    axiom nat_succ_ty : (a : nat') -> (s'(a) : nat');
    x : (a : nat');
    let r = nat_succ_ty(x) : (s'(a) : nat');
    return r;
}

fn nat_succ_cong : true -> cong'(s') {
    axiom nat_succ_cong : true -> cong'(s');
    x : true;
    let r = nat_succ_cong(x) : cong'(s');
    return r;
}

fn nat_succ_eq : a == b -> s'(a) == s'(b) {
    use cong_app_eq;
    use nat_succ_cong;
    use triv;

    x : a == b;
    
    let x2 = triv(nat_succ_cong) : cong'(s');
    let r = cong_app_eq(x2, x) : s'(a) == s'(b);
    return r;
}

fn nat_para_eq_zero_pos : (z' == s'(a)) -> false {
    axiom nat_para_eq_zero_pos : (z' == s'(a)) -> false;
    x : z' == s'(a);
    let r = nat_para_eq_zero_pos(x) : false;
    return r;
}

fn nat_eq_succ_lower : (s'(a) == s'(b)) -> (a == b) {
    axiom nat_eq_succ_lower : (s'(a) == s'(b)) -> (a == b);
    x : s'(a) == s'(b);
    let r = nat_eq_succ_lower(x) : a == b;
    return r;
}

fn nat_para_eq_prev : (a == prev'(a)) -> false {
    axiom nat_para_eq_prev : (a == prev'(a)) -> false;
    x : a == prev'(a);
    let r = nat_para_eq_prev(x) : false;
    return r;
}

/// Definition.
fn nat_def : (a : nat') -> (a == z') | (prev'(a) : nat') & (a == s'(prev'(a))) {
    axiom nat_def : (a : nat') -> (a == z') | (prev'(a) : nat') & (a == s'(prev'(a)));
    x : (a : nat');
    let r = nat_def(x) : (a == z') | (prev'(a) : nat') & (a == s'(prev'(a)));
    return r;
}

/// Existential induction.
fn nat_ind : ex'(z' : nat', a) & ex'(s'(n) : nat', a)^(n : nat') -> a {
    axiom nat_ind : ex'(z' : nat', a) & ex'(s'(n) : nat', a)^(n : nat') -> a;
    x : ex'(z' : nat', a) & ex'(s'(n) : nat', a)^(n : nat');
    let r = nat_ind(x) : a;
    return r;
}

fn nat_one_to : 1' -> s'(z') {
    axiom one_to : 1' -> s'(z');
    x : 1';
    let r = one_to(x) : s'(z');
    return r;
}

fn nat_one_from : s'(z') -> 1' {
    axiom one_from : s'(z') -> 1';
    x : s'(z');
    let r = one_from(x) : 1';
    return r;
}

fn nat_one_eq : true -> 1' == s'(z') {
    x : true;
    use nat_one_from;
    use nat_one_to;
    use refl;
    let y = refl(nat_one_to, nat_one_from) : 1' =^= s'(z');
    use pow_eq_to_tauto_eq;
    let y2 = pow_eq_to_tauto_eq(y) : (1' == s'(z'))^true;
    use triv;
    let r = triv(y2) : 1' == s'(z');
    return r;
}

fn nat_one_ty : true -> (1' : nat') {
    x : true;
    use nat_zero_ty;
    let y = nat_zero_ty(x) : (z' : nat');
    use nat_succ_ty;
    let y2 = nat_succ_ty(y) : (s'(z') : nat');
    use nat_one_eq;
    let x2 = nat_one_eq(x) : 1' == s'(z');
    use ty_eq_left;
    let x3 = ty_eq_left(x2) : (1' : nat') == (s'(z') : nat');
    use snd;
    let x4 = snd(x3) : (s'(z') : nat') => (1' : nat');
    let r = x4(y2) : (1' : nat');
    return r;
}

fn nat_two_to : 2' -> s'(s'(z')) {
    axiom two_to : 2' -> s'(s'(z'));
    x : 2';
    let r = two_to(x) : s'(s'(z'));
    return r;
}

fn nat_two_from : s'(s'(z')) -> 2' {
    axiom two_from : s'(s'(z')) -> 2';
    x : s'(s'(z'));
    let r = two_from(x) : 2';
    return r;
}

fn nat_two_eq : true -> 2' == s'(s'(z')) {
    x : true;
    use nat_two_from;
    use nat_two_to;
    use refl;
    let y = refl(nat_two_to, nat_two_from) : 2' =^= s'(s'(z'));
    use pow_eq_to_tauto_eq;
    let y2 = pow_eq_to_tauto_eq(y) : (2' == s'(s'(z')))^true;
    let r = y2(x) : 2' == s'(s'(z'));
    return r;
}

fn nat_two_ty : true -> (2' : nat') {
    x : true;
    use nat_one_ty;
    let y = nat_one_ty(x) : (1' : nat');
    use nat_one_eq;
    let y2 = nat_one_eq(x) : 1' == s'(z');
    use ty_eq_left;
    let f = ty_eq_left(y2) : (1' : nat') == (s'(z') : nat');
    use fst;
    let f2 = fst(f) : (1' : nat') => (s'(z') : nat');
    let f3 = f2(y) : (s'(z') : nat');
    use nat_succ_ty;
    let f4 = nat_succ_ty(f3) : (s'(s'(z')) : nat');
    use nat_two_eq;
    let y3 = nat_two_eq(x) : 2' == s'(s'(z'));
    let x2 = ty_eq_left(y3) : (2' : nat') == (s'(s'(z')) : nat');
    use snd;
    let x3 = snd(x2) : (s'(s'(z')) : nat') => (2' : nat');
    let r = x3(f4) : (2' : nat');
    return r;
}

fn nat_neq_zero_one : true -> !(z' == s'(z')) {
    x : true;
    use nat_para_eq_zero_pos;
    let r = nat_para_eq_zero_pos() : !(z' == s'(z'));
    return r;
}

fn nat_para_eq_succ : (a : nat') & (a == s'(a)) -> false {
    x : (a : nat');
    y : a == s'(a);

    use nat_def;
    let x2 = nat_def(x) : (a == z') | (prev'(a) : nat') & (a == s'(prev'(a)));

    lam f : !(a == z') {
        z : a == z';
        use eq_symmetry;
        let z2 = eq_symmetry(z) : z' == a;
        use eq_transitivity;
        let z3 = eq_transitivity(z2, y) : z' == s'(a);
        use nat_para_eq_zero_pos;
        let r = nat_para_eq_zero_pos(z3) : false;
        return r;
    }

    lam g : !((prev'(a) : nat') & (a == s'(prev'(a)))) {
        x3 : (prev'(a) : nat');
        y3 : a == s'(prev'(a));
        use eq_symmetry;
        let x4 = eq_symmetry(y) : s'(a) == a;
        use eq_transitivity;
        let x5 = eq_transitivity(x4, y3) : s'(a) == s'(prev'(a));
        use nat_eq_succ_lower;
        let x6 = nat_eq_succ_lower(x5) : a == prev'(a);
        use nat_para_eq_prev;
        let r = nat_para_eq_prev(x6) : false;
        return r;
    }

    let r = match x2 (f, g) : false;
    return r;
}
