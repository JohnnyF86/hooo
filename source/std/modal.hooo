sym Lob;
sym N;
sym N2;
sym K;
sym T;
sym NecToPos;
sym PosToNec;

/// `□(□p => p)`.
fn lob_triv : (p^true => p)^true {
    lam f : p^true => p {
        x : p^true;
        let y = () : true;
        let z = x(y) : p;
        return z;
    }
    return f;
}

/// `(□(□false => false) => □false)  ->  false`.
fn para_lob : (false^true => false)^true => false^true  ->  false {
    x : (false^true => false)^true => false^true;
    use lob_triv;
    let y = lob_triv() : (false^true => false)^true;
    let x2 = x(y) : false^true;
    let x3 = () : true;
    let x4 = x2(x3) : false;
    return x4;
}

/// Demonstrates that Löb's axiom is absurd in HOOO EP.
fn lob_absurd : all((p^true => p)^true => p^true)  ->  false {
    arg : all((p^true => p)^true => p^true);
    let x = arg() : (false^true => false)^true => false^true;
    use para_lob;
    let r = para_lob(x) : false;
    return r;
}

/*
Löb axiom: `□(□p => p) => □p`
Formal expression: `all(Lob'(p))`
*/

/// Reduction of Löb relation.
fn modal_lob_to : Lob'(a)  ->  □(□a => a) => □a {
    axiom modal_lob_to : Lob'(a) -> □(□a => a) => □a;
    x : Lob'(a);
    let r = modal_lob_to(x) : □(□a => a) => □a;
    return r;
}

/// Construction of Löb relation.
fn modal_lob_from : □(□a => a) => □a  ->  Lob'(a) {
    axiom modal_lob_from : □(□a => a) => □a  ->  Lob'(a);
    x : □(□a => a) => □a;
    let r = modal_lob_from(x) : Lob'(a);
    return r;
}

/*
N axiom: `□a => a^true`
Formal expression `all(N'(a))`
*/

/// Reduction of N relation.
fn modal_n_to : N'(a)  ->  a^true => □a {
    axiom modal_n_to : N'(a) -> a^true => □a;
    x : N'(a);
    let r = modal_n_to(x) : a^true => □a;
    return r;
}

/// Construciton of N relation.
fn modal_n_from : a^true => □a  ->  N'(a) {
    axiom modal_n_from : a^true => □a -> N'(a);
    x : a^true => □a;
    let r = modal_n_from(x) : N'(a);
    return r;
}

/*
N2 axiom `□a == a^true
Formal expression `all(N2'(a))`
*/

/// Reduction of N2 relation.
fn modal_n2_to : N2'(a)  ->  □a == a^true {
    axiom modal_n2_to : N2'(a) -> □a == a^true;
    x : N2'(a);
    let r = modal_n2_to(x) : □a == a^true;
    return r;
}

/// Construction of N2 relation.
fn modal_n2_from : □a == a^true  ->  N2'(a) {
    axiom modal_n2_from : □a == a^true -> N2'(a);
    x : □a == a^true;
    let r = modal_n2_from(x) : N2'(a);
    return r;
}

/*
K axiom: `□(a => b) => (□a => □b)`
Formal expression: `all(K'(a, b))`
*/

/// Reduction of K relation.
fn modal_k_to : K'(a, b)  ->  □(a => b) => (□a => □b) {
    axiom modal_k_to : K'(a, b) -> □(a => b) => (□a => □b);
    x : K'(a, b);
    let r = modal_k_to(x) : □(a => b) => (□a => □b);
    return r;
}

/// Construction of K relation.
fn modal_k_from : □(a => b) => (□a => □b)  ->  K'(a, b) {
    axiom modal_k_from : □(a => b) => (□a => □b) -> K'(a, b);
    x : □(a => b) => (□a => □b);
    let r = modal_k_from(x) : K'(a, b);
    return r;
}

/*
T axiom: `□a => a`
Formal expression: `all(T'(a))`
*/

/// Reduction of T relation.
fn modal_t_to : T'(a)  ->  □a => a {
    axiom modal_t_to : T'(a) -> □a => a;
    x : T'(a);
    let r = modal_t_to(x) : □a => a;
    return r;
}

/// Construction of T relation.
fn modal_t_from : □a => a  ->  T'(a) {
    axiom modal_t_from : □a => a -> T'(a);
    x : □a => a;
    let r = modal_t_from(x) : T'(a);
    return r;
}

/// Axiom N2 implies axiom N.
fn modal_n2_to_n : N2'(a)  ->  N'(a) {
    x : N2'(a);
    use modal_n2_to;
    let x3 = modal_n2_to(x) : □a == a^true;
    use snd;
    let x4 = snd(x3) : a^true => □a;
    use modal_n_from;
    let r = modal_n_from(x4) : N'(a);
    return r;
}

/// Axiom N2 implies axiom K.
fn modal_n2_to_k : all(N2'(a))  ->  K'(a, b) {
    x : all(N2'(a));
    let xa = x() : N2'(a);
    let xb = x() : N2'(b);
    let xab = x() : N2'(a => b);
    use modal_n2_to;
    let eq_nec_a_tauto_a = modal_n2_to(xa) : □a == a^true;
    let eq_nec_b_tauto_b = modal_n2_to(xb) : □b == b^true;
    let eq_nec_ab_tauto_ab = modal_n2_to(xab) : □(a => b) == (a => b)^true;
    use fst;
    let nec_a_to_tauto_a = fst(eq_nec_a_tauto_a) : □a => a^true;
    let nec_ab_to_tauto_ab = fst(eq_nec_ab_tauto_ab) : □(a => b) => (a => b)^true;
    use snd;
    let tauto_b_to_nec_b = snd(eq_nec_b_tauto_b) : b^true => □b;
    use hooo_imply;
    let f = hooo_imply() : (a => b)^true => (a^true => b^true);
    use imply_transitivity;
    let f2 = imply_transitivity(nec_ab_to_tauto_ab, f) : □(a => b) => (a^true => b^true);
    lam g : (a^true => b^true) => (□a => □b) {
        x : a^true => b^true;
        use imply_transitivity;
        let x2 = imply_transitivity(nec_a_to_tauto_a, x) : □a => b^true;
        let r = imply_transitivity(x2, tauto_b_to_nec_b) : □a => □b;
        return r;
    }
    let f3 = imply_transitivity(f2, g) : □(a => b) => (□a => □b);
    use modal_k_from;
    let r = modal_k_from(f3) : K'(a, b);
    return r;
}

/// Axiom N2 implies axiom T.
fn modal_n2_to_t : all(N2'(a))  ->  T'(a) {
    x : all(N2'(a));
    let x2 = x() : N2'(a);
    use modal_n2_to;
    use triv;
    let f = triv() : a^true => a;
    let eq_nec_a_tauto_a = modal_n2_to(x2) : □a == a^true;
    use fst;
    let x3 = fst(eq_nec_a_tauto_a) : □a => a^true;
    use imply_transitivity;
    let x4 = imply_transitivity(x3, f) : □a => a;
    use modal_t_from;
    let r = modal_t_from(x4) : T'(a);
    return r;
}

/*
NecToPos axiom: `□a == !◇!a`
Formal expression: `all(NecToPos'(a))`
*/

/// Reduction of NecToPos relation.
fn modal_nec_to_pos_to : NecToPos'(a)  ->  □a == !◇!a {
    axiom modal_nec_to_pos_to : NecToPos'(a) -> □a == !◇!a;
    x : NecToPos'(a);
    let r = modal_nec_to_pos_to(x) : □a == !◇!a;
    return r;
}

/// Construction of NecToPos relation.
fn modal_nec_to_pos_from : □a == !◇!a  ->  NecToPos'(a) {
    axiom modal_nec_to_pos_from : □a == !◇!a -> NecToPos'(a);
    x : □a == !◇!a;
    let r = modal_nec_to_pos_from(x) : NecToPos'(a);
    return r;
}

/*
PosToNec axiom: `◇a == !□!a`
Formal expression: `all(PosToNec'(a))`
*/

/// Reduction of PosToNec relation.
fn modal_pos_to_nec_to : PosToNec'(a)  ->  ◇a == !□!a {
    axiom modal_pos_to_nec_to : PosToNec'(a) -> ◇a == !□!a;
    x : PosToNec'(a);
    let r = modal_pos_to_nec_to(x) : ◇a == !□!a;
    return r;
}

/// Construction of PosToNec relation.
fn modal_pos_to_nec_from : ◇a == !□!a  ->  PosToNec'(a) {
    axiom modal_pos_to_nec_from : ◇a == !□!a -> PosToNec'(a);
    x : ◇a == !□!a;
    let r = modal_pos_to_nec_from(x) : PosToNec'(a);
    return r;
}

/// `□a & (a == b)  ->  □a`.
fn modal_nec_in_arg : □a & (a == b)  ->  □b {
    axiom modal_nec_in_arg : □a & (a == b) -> □b;
    x : □a;
    y : a == b;
    let r = modal_nec_in_arg(x, y) : □b;
    return r;
}

/// `◇a & (a == b)  ->  ◇b`.
fn modal_pos_in_arg : ◇a & (a == b)  ->  ◇b {
    axiom modal_pos_in_arg : ◇a & (a == b) -> ◇b;
    x : ◇a;
    y : a == b;
    let r = modal_pos_in_arg(x, y) : ◇b;
    return r;
}

fn modal_nec_eq : (a == b)  ->  □a == □b {
    x : a == b;
    lam f : □a => □b {
        y : □a;
        use modal_nec_in_arg;
        let r = modal_nec_in_arg(y, x) : □b;
        return r;
    }
    lam g : □b => □a {
        y : □b;
        use eq_symmetry;
        let x2 = eq_symmetry(x) : b == a;
        use modal_nec_in_arg;
        let r = modal_nec_in_arg(y, x2) : □a;
        return r;
    }
    use refl;
    let r = refl(f, g) : □a == □b;
    return r;
}

fn modal_pos_eq : (a == b)  ->  ◇a == ◇b {
    x : a == b;
    lam f : ◇a => ◇b {
        y : ◇a;
        use modal_pos_in_arg;
        let r = modal_pos_in_arg(y, x) : ◇b;
        return r;
    }
    lam g : ◇b => ◇a {
        y : ◇b;
        use eq_symmetry;
        let x2 = eq_symmetry(x) : b == a;
        use modal_pos_in_arg;
        let r = modal_pos_in_arg(y, x2) : ◇a;
        return r;
    }
    use refl;
    let r = refl(f, g) : ◇a == ◇b;
    return r;
}

fn modal_tauto_excm_to_imply_nec_to_pos_pos_to_nec :
    all(excm(a)^true)  ->  all(NecToPos'(a)) => PosToNec'(a)
{
    x : all(excm(a)^true);
    lam f : all(NecToPos'(a)) => PosToNec'(a) {
        use eq_modus_tollens;
        use eq_symmetry;
        use eq_transitivity;
        use modal_nec_to_pos_to;
        use modal_pos_eq;
        use modal_pos_to_nec_from;
        use not_excm_to_eq_nn;
        use triv;
        
        let x2 = x() : excm(◇!!a)^true;
        let x3 = triv(x2) : excm(◇!!a);
        let x4 = not_excm_to_eq_nn(x3) : ◇!!a == !!◇!!a;
        let x5 = eq_symmetry(x4) : !!◇!!a == ◇!!a;
        
        let x6 = x() : excm(a)^true;
        let x7 = triv(x6) : excm(a);
        let x8 = not_excm_to_eq_nn(x7) : a == !!a;
        
        y : all(NecToPos'(a));
        let y1 = y() : NecToPos'(!a);
        let y2 = modal_nec_to_pos_to(y1) : □!a == !◇!!a;
        let y3 = eq_modus_tollens(y2) : !□!a == !!◇!!a;
        let y4 = eq_transitivity(y3, x5) : !□!a == ◇!!a;
        let y6 = eq_symmetry(y4) : ◇!!a == !□!a;
        let y7 = modal_pos_eq(x8) : ◇a == ◇!!a;
        let y8 = eq_transitivity(y7, y6) : ◇a == !□!a;
        let r = modal_pos_to_nec_from(y8) : PosToNec'(a);
        return r;
    }
    return f;
}

fn modal_tauto_excm_to_imply_pos_to_nec_nec_to_pos :
    all(excm(a)^true)  ->  all(PosToNec'(a)) => NecToPos'(a)
{
    x : all(excm(a)^true);
    lam f : all(PosToNec'(a)) => NecToPos'(a) {
        use eq_modus_tollens;
        use eq_symmetry;
        use eq_transitivity;
        use modal_nec_eq;
        use modal_nec_to_pos_from;
        use modal_pos_to_nec_to;
        use not_excm_to_eq_nn;
        use triv;

        let x2 = x() : excm(□!!a)^true;
        let x3 = triv(x2) : excm(□!!a);
        let x4 = not_excm_to_eq_nn(x3) : □!!a == !!□!!a;
        let x5 = eq_symmetry(x4) : !!□!!a == □!!a;

        let x6 = x() : excm(a)^true;
        let x7 = triv(x6) : excm(a);
        let x8 = not_excm_to_eq_nn(x7) : a == !!a;

        y : all(PosToNec'(a));
        let y2 = y() : PosToNec'(!a);
        let y3 = modal_pos_to_nec_to(y2) : ◇!a == !□!!a;
        let y4 = eq_modus_tollens(y3) : !◇!a == !!□!!a;
        let y5 = eq_transitivity(y4, x5) : !◇!a == □!!a;
        let y6 = eq_symmetry(y5) : □!!a == !◇!a;
        let y7 = modal_nec_eq(x8) : □a == □!!a;
        let y8 = eq_transitivity(y7, y6) : □a == !◇!a;
        let r = modal_nec_to_pos_from(y8) : NecToPos'(a);
        return r;
    }
    return f;
}

/// There is no consistent modal logic of the Löb axiom in HOOO EP (N2).
fn modal_n2_to_nlob : all(N2'(a))  ->  !all(Lob'(a)) {
    x : all(N2'(a));
    lam f : !all(Lob'(a)) {
        use eq_transitivity;
        use imply_eq_left;
        use imply_in_left_arg;
        use imply_in_right_arg;
        use modal_lob_to;
        use modal_n2_to;
        use modal_nec_eq;
        use para_lob;

        y : all(Lob'(a));
        let y2 = y() : Lob'(false);
        let y3 = modal_lob_to(y2) : □(□false => false) => □false;
        
        let x2 = x() : N2'(false);
        let x3 = modal_n2_to(x2) : □false == false^true;

        let x4 = imply_eq_left(x3) : (□false => false) == (false^true => false);
        let x5 = modal_nec_eq(x4) : □(□false => false) == □(false^true => false);

        let x6 = x() : N2'(false^true => false);
        let x7 = modal_n2_to(x6) : □(false^true => false) == (false^true => false)^true;

        let x8 = eq_transitivity(x5, x7) : □(□false => false) == (false^true => false)^true;
        let x9 = imply_in_left_arg(y3, x8) : (false^true => false)^true => □false;
        let x10 = imply_in_right_arg(x9, x3) : (false^true => false)^true => false^true;
        let r = para_lob(x10) : false;
        return r;
    }
    return f;
}

fn modal_tauto_n2_to_para_nec_false : all(N2'(a))^true  ->  false^(□false) {
    x : all(N2'(a))^true;
   
    fn h : all(N2'(a))  ->  N2'(false) {
        k : all(N2'(a));
        let r = k() : N2'(false);
        return r;
    }
 
    use pow_transitivity;
    let x2 = pow_transitivity(x, h) : N2'(false)^true;
    use modal_n2_to;
    let f2 = modal_n2_to() : N2'(false) -> □false == false^true;
    let x3 = pow_transitivity(x2, f2) : (□false == false^true)^true;
    use fst;
    let f3 = fst() : (□false == false^true) -> (□false => false^true);
    let x4 = pow_transitivity(x3, f3) : (□false => false^true)^true;
    
    fn f : □false => false^true  ->  □false => false {
        x : □false => false^true;
        lam g : □false => false {
            y : □false;
            let y2 = x(y) : false^true;
            use triv;
            let r = triv(y2) : false;
            return r;
        }
        return g;
    }

    let x5 = pow_transitivity(x4, f) : (!□false)^true;
    use tauto_not_to_para;
    let r = tauto_not_to_para(x5) : false^(□false);
    return r;
}

fn modal_tauto_t_to_para_nec_false : all(T'(a))^true  ->  false^(□false) {
    x : all(T'(a))^true;

    fn f : all(T'(a)) -> T'(false) {
        y : all(T'(a));
        let r = y() : T'(false);
        return r;
    }

    use pow_transitivity;
    let x2 = pow_transitivity(x, f) : T'(false)^true;
    use modal_t_to;
    let f2 = modal_t_to() : T'(false) -> !□false;
    let x3 = pow_transitivity(x2, f2) : (!□false)^true;

    use tauto_not_to_para;
    let r = tauto_not_to_para(x3) : false^(□false);
    return r;
}

fn modal_n_to_nlob : all(N'(a)) & false^(□false)  ->  !all(Lob'(a)) {
    x : all(N'(a));
    y0 : false^(□false);

    use para_to_tauto_not;
    let y = para_to_tauto_not(y0) : (□false => false)^true;

    let x2 = x() : N'(□false => false);
    use modal_n_to;
    let x3 = modal_n_to(x2) : (□false => false)^true => □(□false => false);
    let y2 = x3(y) : □(□false => false);

    use triv;
    let w = triv(y) : □false => false;

    lam f : !all(Lob'(a)) {
        z : all(Lob'(a));
        let z2 = z() : Lob'(false);
        use modal_lob_to;
        let z3 = modal_lob_to(z2) : □(□false => false) => □false;
        let z4 = z3(y2) : □false;
        let r = w(z4) : false;
        return r;
    }

    return f;
}

