use cong;

fn comp_ty : (f : a -> b) & (g : b -> c) -> ((f . g) : a -> c) {
    axiom comp_ty : (f : a -> b) & (g : b -> c) -> ((f . g) : a -> c);
    x : (f : a -> b) & (g : b -> c);
    let r = comp_ty(x) : ((f . g) : a -> c);
    return r;
}

fn comp_def : true -> (f . g)(a) == f(g(a)) {
    axiom comp_def : true -> (f . g)(a) == f(g(a));
    x : true;
    let r = comp_def(x) : (f . g)(a) == f(g(a));
    return r;
}

fn comp_cong : cong'(f) & cong'(g) -> cong'(f . g) {
    axiom comp_cong : cong'(f) & cong'(g) -> cong'(f . g);
    x : cong'(f) & cong'(g);
    let r = comp_cong(x) : cong'(f . g);
    return r;
}

fn comp_tup_app : true -> (h . (f, g))(a) == h(f(a), g(a)) {
    axiom comp_tup_app : true -> (h . (f, g))(a) == h(f(a), g(a));
    x : true;
    let r = comp_tup_app(x) : (h . (f, g))(a) == h(f(a), g(a));
    return r;
}

